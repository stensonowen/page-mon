// :setf rust
use std::str::FromStr;
use ast;

grammar;

// Cron Grammar: 
// (shortcuts are taken for readability/convenience so this isn't exactly right)
// mostly based on http://linux.die.net/man/5/crontab
// 
//      Start   →   Entries
//      Entries →   Entry_ Entry_ Entry_ Entry_ Entry_ Url
//     {Entry_  →   Entry Entry'    }this can be elided using crate macro
//     {Entry'  →   , Entry_  |  ε  } cleaner (also is ε possible?)
//      Entry   →   Special  |  Num  |  */ Num  |  # Num  |  Num - Num
//      Special →   *|?|L|W
//     {Num     →   Num_ Num'               }much easier/more elegant to 
//     {Num_    →   0  |  1  |  ...  |  9   } define numbers using the regex
//     {Num'    →   Num  |  ε               } [0-9]+
// 
// Note about whitespace:
//      LALRPOP does not treat whitespace as a token. Instead space and tab 
//      represent sometimes-optional delmiiters. Therefore whitespace can
//      be omitted when doing so would not cause ambiguity. 
//      For example, `*****https://google.com` must mean that every field 
//      is `*` (except the url), because `**` is never a valid token.
//      Numbers, however, are an exception to this exception, as in
//      `01234https://google.com`, `01234` will be treated as one number.
//      I'm pretty sure the whitespace rule can be simplified to "whitespace
//      is only necessary when it is between two digits".
//      But again, whitespace is never problematic. That is to say, the 
//      croncfg language includes every valid crontab line as well as 
//      every version of that line in which removing whitespace did not
//      introduce ambiguity.
//
// TODO: more special chars, i.e. JAN-DEC, SUN-SAT
// TODO: make parsing context-specific specials part of grammar (I guess)
// TODO: add parsing for comment? r"^\s*#.*" or environment setting? (e.g. mailto)
// TODO: better naming convention?

pub Line: ast::Line = {
    <cmd:Command>   => ast::Line::Cmd(cmd),
    <Comment>         //=> ast::Line::Comment,
};

pub Command: ast::Command = {
    <e0:Entry> <e1:Entry> <e2:Entry> <e3:Entry_Month> <e4:Entry_Day> <u:Url> => 
        ast::Command{ minute:e0, hour:e1, date:e2, month:e3, weekday:e4, url:u.to_owned() },
    "@yearly" <u:Url>   => ast::Command {    
        minute:     vec![ast::Value::CV(ast::ContVal::Constant(0))],
        hour:       vec![ast::Value::CV(ast::ContVal::Constant(0))],
        date:       vec![ast::Value::CV(ast::ContVal::Constant(1))],
        month:      vec![ast::Value::CV(ast::ContVal::Constant(1))],
        weekday:    vec![ast::Value::CV(ast::ContVal::Asterisk)],
        url: u.to_owned(),
    },
    //TODO: rest (less verbose way?)
    //reboot??
};

pub Comment: ast::Line = {
    r"#.*" => ast::Line::Comment,
};

//pub Nickname: u8 = {
//    "@reboot" => 0,
//    "@yearly"     =>  0 0 1 1 *
//    "@annually"   =>  0 0 1 1 *
//    "@monthly"    =>  0 0 1 * *
//    "@weekly"     =>  0 0 * * 0
//    "@daily"      =>  0 0 * * * 
//    "@hourly"     =>  0 * * * * 
//};

pub Entry_Day = {
    Entry,
    <d:DayOfWeek> => vec![ast::Value::CV(ast::ContVal::Constant(d))],
};

pub Entry_Month = {
    <Entry>,
    <m:MonthOfYear> => vec![ast::Value::CV(ast::ContVal::Constant(m))],
};

pub Entry = Comma<Value>; 

Comma<Value>: Vec<Value> = {
    <val:Value> <vec:("," <Value>)*> => {
        let mut vec = vec;
        vec.push(val);
        vec
    }
};

Value: ast::Value = {
    <cv:ContVal>            => ast::Value::CV(cv),
    <cv:ContVal> <s:Skip>   => ast::Value::Skip(cv, s),
};

Skip = "/" <Num>;


ContVal: ast::ContVal = {
    "*"                 => ast::ContVal::Asterisk,
    <n:Num>             => ast::ContVal::Constant(n),
    <n:Num> "-" <m:Num> => ast::ContVal::Range(n,m),    
};
    




    


DayOfWeek: u8 = {
    //starts from 0
    "SUN" => 0,
    "MON" => 1,
    "TUE" => 2,
    "WED" => 3,
    "THU" => 4,
    "FRI" => 5,
    "SAT" => 6,
};

MonthOfYear: u8 = {
    //starts from 1
    "JAN" => 1,
    "FEB" => 2,
    "MAR" => 3,
    "APR" => 4,
    "MAY" => 5,
    "JUN" => 6,
    "JUL" => 7,
    "AUG" => 8,
    "SEP" => 9,
    "OCT" => 10,
    "NOV" => 11,
    "DEC" => 12,
};


Num: u8 = <n:r"[0-9]+"> => u8::from_str(n).unwrap();

//TODO: pick one
//Should urls have to start with http(s)?
//Option1 ('no') is more convenient but more prone to user-error 
//First char can't be \d, so there would be a weird error if url were
// an IP address that didn't start with http(s).
//  e.g. Option 1: `google.com` is well-formed but `8.8.8.8` is not
//  e.g. Option 2: `https://google.com` and `https://8.8.8.8` are well-formed
//Url could be parsed that starts with a special character, which 
// could disguise errors; 
//  e.g. Option 1: `*****google.com` and `******google.com` both well-formed
//  e.g. Option 2: `*****https://google.com` is well-formed 
//      but `******https://google.com` is not
//Url = r"[^0-9\s]+";               //Option1
Url = r"https?://.+[\d\w-\.]+";     //Option2
//Would be ambiguous (c.f. Num) if url started with [\d] 
//Easier to just require http/https before url

