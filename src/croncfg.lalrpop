// :setf rust
use std::str::FromStr;
use ast;

grammar;

// Cron Grammar: 
//  mostly based on http://linux.die.net/man/5/crontab
// 
// Note about whitespace:
//      LALRPOP does not treat whitespace as a token. Instead space and tab 
//      represent sometimes-optional delmiiters. Therefore whitespace can
//      be omitted when doing so would not cause ambiguity. 
//      For example, `*****https://google.com` must mean that every field 
//      is `*` (except the url), because `**` is never a valid token.
//      Numbers, however, are an exception to this exception, as in
//      `01234https://google.com`, `01234` will be treated as one number.
//      I'm pretty sure the whitespace rule can be simplified to "whitespace
//      is only necessary when it is between two digits".
//      But again, whitespace is never problematic. That is to say, the 
//      croncfg language includes every valid crontab line as well as 
//      every version of that line in which removing whitespace did not
//      introduce ambiguity.
//
// TODO: add parsing for environment setting? (e.g. mailto)

pub Line: ast::Line = {
    <cmd:Command>   => ast::Line::Cmd(cmd),
    <Comment>
};


Command: ast::Command = {
    <t:Time> <u:Url>    => {
        let mut cmd = t;
        cmd.url = Some(u.to_owned());
        cmd
    }
};
    

Time: ast::Command = {
    <a:Entry> <b:Entry> <c:Entry> <d:Entry_Month> <e:Entry_Day> => 
        ast::Command{ minute:a, hour:b, date:c, month:d, weekday:e, url:None },
    <Nickname>,
};
    

Nickname: ast::Command = {
    r"(?i)@yearly"   => ast::Command {    
        minute:     vec![ast::Value::Constant(0)],
        hour:       vec![ast::Value::Constant(0)],
        date:       vec![ast::Value::Constant(1)],
        month:      vec![ast::Value::Constant(1)],
        weekday:    vec![ast::Value::CV(ast::ContVal::Asterisk)],
        url:        None,
    }
    //TODO: do the others less verbosely?
};


Comment: ast::Line = {
    r"#.*" => ast::Line::Comment,
};

//Nickname: u8 = {
//    "@reboot" => 0,
//    "@yearly"     =>  0 0 1 1 *
//    "@annually"   =>  0 0 1 1 *
//    "@monthly"    =>  0 0 1 * *
//    "@weekly"     =>  0 0 * * 0
//    "@daily"      =>  0 0 * * * 
//    "@hourly"     =>  0 * * * * 
//};

Entry_Day = {
    Entry,
    <d:DayOfWeek> => vec![ast::Value::Constant(d)],
};

Entry_Month = {
    <Entry>,
    <m:MonthOfYear> => vec![ast::Value::Constant(m)],
};

Entry = Comma<Value>; 

Comma<Value>: Vec<Value> = {
    <val:Value> <vec:("," <Value>)*> => {
        let mut vec = vec;
        vec.push(val);
        vec
    }
};

Value: ast::Value = {
    <n:Num>                 => ast::Value::Constant(n),
    <cv:ContVal>            => ast::Value::CV(cv),
    <cv:ContVal> <s:Skip>   => ast::Value::Skip(cv, s),
};

Skip = "/" <Num>;

ContVal: ast::ContVal = {
    "*"                 => ast::ContVal::Asterisk,
    //<n:Num>             => ast::ContVal::Constant(n),
    <n:Num> "-" <m:Num> => ast::ContVal::Range(n,m),    
};
    
//Case insensitive by using regex with the `i` flag

DayOfWeek: u8 = {
    //starts from 0
    r"(?i)SUN" => 0,
    r"(?i)MON" => 1,
    r"(?i)TUE" => 2,
    r"(?i)WED" => 3,
    r"(?i)THU" => 4,
    r"(?i)FRI" => 5,
    r"(?i)SAT" => 6,
};

MonthOfYear: u8 = {
    //starts from 1
    r"(?i)JAN" => 1,
    r"(?i)FEB" => 2,
    r"(?i)MAR" => 3,
    r"(?i)APR" => 4,
    r"(?i)MAY" => 5,
    r"(?i)JUN" => 6,
    r"(?i)JUL" => 7,
    r"(?i)AUG" => 8,
    r"(?i)SEP" => 9,
    r"(?i)OCT" => 10,
    r"(?i)NOV" => 11,
    r"(?i)DEC" => 12,
};


Num: u8 = <n:r"[0-9]+"> => u8::from_str(n).unwrap();

//TODO: pick one
//Should urls have to start with http(s)?
//Option1 ('no') is more convenient but more prone to user-error 
//First char can't be \d, so there would be a weird error if url were
// an IP address that didn't start with http(s).
//  e.g. Option 1: `google.com` is well-formed but `8.8.8.8` is not
//  e.g. Option 2: `https://google.com` and `https://8.8.8.8` are well-formed
//Url could be parsed that starts with a special character, which 
// could disguise errors; 
//  e.g. Option 1: `*****google.com` and `******google.com` both well-formed
//  e.g. Option 2: `*****https://google.com` is well-formed 
//      but `******https://google.com` is not
//Url = r"[^0-9\s]+";               //Option1
//Url = r"https?://.+[\d\w-\.]+";     //Option2
Url = r"https?://[^\d\s]+";     //Option2
//Would be ambiguous (c.f. Num) if url started with [\d] 
//Easier to just require http/https before url

